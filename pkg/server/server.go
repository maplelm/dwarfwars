package server

/*
* WARNING: CURRENTLY NOT VALIDATING CONNECTIONS OR TRAFFIC.
* WARNING: No Authentication is required.
 *
 * FIX: need to acount for bytes not being sent all at once
 * FIX: Connections currently do not timeout leading to a runaway goruitines
*/

import (
	"context"
	"fmt"
	"log"
	"net"
	"sync"
	"time"
)

type Server struct {
	Addr        string         // Address the server will listen on
	Port        string         // Listening Port
	Quitting    bool           // If true server will shutdown
	exit        chan struct{}  // used to close down the server
	waitGroup   sync.WaitGroup // tracking goruitines for connections so they can shutdown properly
	idleTimeout time.Duration
	ctx         context.Context
}

func New(addr, port string, timeout time.Duration) (s *Server, err error) {
	s = &Server{
		Addr:        addr,
		Port:        port,
		Quitting:    false,
		exit:        make(chan struct{}),
		idleTimeout: timeout,
	}
	return
}

// Returns the Full Formated listening Address and Port for the server
func (s *Server) FullAddr() string {
	return fmt.Sprintf("%s:%s", s.Addr, s.Port)
}

func (s *Server) StartTCP(ctx context.Context) (err error) {

	// Create the TCP Listener
	listener, err := net.Listen("tcp", s.FullAddr())
	if err != nil {
		log.Printf("(Server) Failed to create listener for TCP server, %s", err)
		return
	}

	// Creating Child context to for all the connections generated by the server
	servCtx, _ := context.WithCancel(ctx)

	//begin listening for clients
	go s.listen(servCtx, listener)

	select {
	case <-servCtx.Done():
		log.Printf("Server shutting down, exiting the start command")
		return servCtx.Err()
	}
}

func (s *Server) StartUDP() (err error) {

	//addr, err := net.ResolveUDPAddr("udp", s.FullAddr())

	if err != nil {
		return
	}
	return
}

func (s *Server) Wait() {
	s.waitGroup.Wait()
}

func (s *Server) listen(ctx context.Context, l net.Listener) (err error) {
	s.waitGroup.Add(1)
	defer s.waitGroup.Done()

	if l.Addr().Network() == "tcp" {
		//////////////////
		// TCP Listener //
		//////////////////
		for {
			select {
			case <-ctx.Done():
				return ctx.Err()
			default:
				conn, err := l.Accept()
				if err != nil {
					select {
					case <-ctx.Done():
						return ctx.Err()
					default:
						log.Printf("(Server) TCP Accept Function Failed, continueing to listen: %s", err)
						continue
					}
				}
				go s.tcpHandle(ctx, conn)
			}
		}

	} else if l.Addr().Network() == "upd" {
		////////////////// NOTE: Not Implemented
		// UDP Listener //
		//////////////////
		for {
			select {
			case <-ctx.Done():
				return ctx.Err()
			default:

			}
		}
	} else {
		/////////////////////
		// UNKOWN Listener //
		/////////////////////
		log.Printf("(Dwarf Wars Server) Unsupported Listener type, Exiting")
	}
	return
}

func (s *Server) tcpHandle(ctx context.Context, conn net.Conn) (err error) {
	s.waitGroup.Add(1)
	defer s.waitGroup.Done()
	defer conn.Close()
	log.Printf("Server Accepted Connection from %s", conn.RemoteAddr())

	lastRead := time.Now()
	lastWrite := time.Now()

	waitG := sync.WaitGroup{}

	readCtx, readCancel := context.WithCancel(ctx)
	writeCtx, writeCancel := context.WithCancel(ctx)

	// Reading From Connection
	go func(c context.Context, cn net.Conn) error {
		waitG.Add(1)
		defer waitG.Done()
		for {
			select {
			case <-c.Done():
				return c.Err()
			default:
				// do something
			}
		}
	}(readCtx, conn)
	// Writing to Connection
	go func(c context.Context, cn net.Conn) error {
		waitG.Add(1)
		defer waitG.Done()
		for {
			select {
			case <-c.Done():
				return c.Err()
			default:
				// do something
			}
		}
	}(writeCtx, conn)

	for {
		if time.Since(lastRead) >= time.Minute && time.Since(lastWrite) >= time.Minute {
			readCancel()
			writeCancel()
			log.Printf("(Dwarf Wars Server) Closing Connection due to inactivity (%s)", conn.RemoteAddr())
			conn.Close()
			waitG.Wait()
			return
		}
		time.Sleep(time.Millisecond)
	}
}
