package server

/*
* WARNING: CURRENTLY NOT VALIDATING CONNECTIONS OR TRAFFIC.
* WARNING: No Authentication is required.
 *
 * FIX: need to acount for bytes not being sent all at once
 * FIX: Connections currently do not timeout leading to a runaway goruitines
*/

import (
	"context"
	"fmt"
	"github.com/maplelm/dwarfwars/pkg/tcp"
	"log"
	"net"
	"sync"
	"time"
)

const (
	PoolPublic = iota
)

type Server struct {
	Addr        string         // Address the server will listen on
	Port        string         // Listening Port
	Quitting    bool           // If true server will shutdown
	exit        chan struct{}  // used to close down the server
	waitGroup   sync.WaitGroup // tracking goruitines for connections so they can shutdown properly
	idleTimeout time.Duration
	connPool    map[net.Addr]net.Conn
	ctx         context.Context
}

func New(addr, port string, timeout time.Duration) (s *Server, err error) {
	s = &Server{
		Addr:        addr,
		Port:        port,
		Quitting:    false,
		exit:        make(chan struct{}),
		idleTimeout: timeout,
		connPool:    make(map[net.Addr]net.Conn),
	}
	return
}

// Returns the Full Formated listening Address and Port for the server
func (s *Server) FullAddr() string {
	return fmt.Sprintf("%s:%s", s.Addr, s.Port)
}

func (s *Server) StartTCP(ctx context.Context) (err error) {

	// Create the TCP Listener
	listener, err := net.Listen("tcp", s.FullAddr())
	if err != nil {
		log.Printf("(Server) Failed to create listener for TCP server, %s", err)
		return
	}

	// Creating Child context to for all the connections generated by the server
	servCtx, _ := context.WithCancel(ctx)

	//begin listening for clients
	go s.listen(servCtx, listener)

	select {
	case <-servCtx.Done():
		log.Printf("Server shutting down, exiting the start command")
		return servCtx.Err()
	}
}

func (s *Server) StartUDP() (err error) {
	addr, err := net.ResolveUDPAddr("udp", s.FullAddr())
	if err != nil {
		return
	}
	return
}

func (s *Server) Wait() {
	s.waitGroup.Wait()
}

func (s *Server) listen(ctx context.Context, l net.Listener) (err error) {
	s.waitGroup.Add(1)
	defer s.waitGroup.Done()

	if l.Addr().Network() == "tcp" {
		//////////////////
		// TCP Listener //
		//////////////////
		for {
			conn, err := l.Accept()
			if err != nil {
				select {
				case <-ctx.Done():
					return ctx.Err()
				default:
					log.Printf("(Server) TCP Accept Function Failed, continueing to listen: %s", err)
					continue
				}
			}
			if _, ok := s.connPool[conn.RemoteAddr()]; !ok {
				s.connPool[conn.RemoteAddr()] = conn
			} else {
				log.Printf(" Connection for %s already exists", conn.RemoteAddr().String())
				continue
			}
			go s.accept(ctx, s.connPool[conn.RemoteAddr()])
		}
	} else if l.Addr().Network() == "upd" {
		//////////////////
		// UDP Listener //
		//////////////////
		for {
		}
	} else {
		/////////////////////
		// UNKOWN Listener //
		/////////////////////
	}
	return
}

func (s *Server) accept(ctx context.Context, conn net.Conn) (err error) {
	s.waitGroup.Add(1)
	defer s.waitGroup.Done()

	defer (*conn).Close()

	log.Printf("Server Accepted Connection from %s", conn.RemoteAddr())

	for {
		select {

		case <-ctx.Done():
			return ctx.Err()

		default:
			// Making the server echo for now
			var cmd tcp.Command
			var data []byte
			rn, err := conn.Read(data)
			if err != nil {
				log.Printf("Conn (%s) Error: %s", conn.RemoteAddr(), err)
			}
			err = cmd.UnmarshalBinary(data)
			if err != nil {
				log.Printf("Failed to Unmarshal command from client: %s", err)
				continue
			}

			response, err := cmd.MarshalBinary()
			if err != nil {
				log.Printf("Failed to Marshal Binary command for client: %s", err)
				continue
			}

			wn, err := conn.Write(response)
			if err != nil {
				log.Printf("Conn (%s) Error: %s", conn.RemoteAddr(), err)
			}
			if wn != rn {
				log.Printf("Conn (%s) Warning: read and write data lengths do not match R: %d, W: %d", conn.RemoteAddr(), rn, wn)
			}

		}
	}
}
